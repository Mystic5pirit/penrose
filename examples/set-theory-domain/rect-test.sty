-- Based off venn.sty

-- TODO: Choice between `disjoint` (query impl) and `disjointOld` (area overlap using overlap1D)
-- `disjointOld` works on the NaN one but causes the first one to basically NaN and some of the objectives to be unsatisfied elsewhere
-- Also choice of padding - without padding, the 1st one NaNs but the 2nd one doesn't

canvas {
  width = 800
  height = 700
}

forall Set x {
    x.icon = Rectangle {
        strokeWidth : 0.0
        center: (0,0)
        w: 400.
        h: 500.
    }

    x.text = Text {
        string : x.label
    }

    ensure subset(x.text, x.icon)
    ensure minSize(x.icon)
    ensure maxSize(x.icon, canvas.height / 3)
    encourage sameCenter(x.text, x.icon)
    x.textLayering = x.text above x.icon
}

forall Set x; Set y
where IsSubset(x, y) {

      -- TODO: Revert
    -- ensure disjoint(y.text, x.icon, 30.0)
    ensure disjoint(y.text, x.icon, 0.0)

    ensure subset(x.icon, y.icon)
    -- ensure disjoint(y.text, x.icon)
    -- ensure contains(y.icon, x.icon)
    x.icon above y.icon
}

---

forall Set x; Set y
where Not(Intersecting(x, y)) {
    -- ensure disjointBBox(x.icon, y.icon, 20.0)
    ensure disjoint(x.icon, y.icon)
}

-- --------- NEW


forall Set x; Set y
where Intersecting(x, y) {
    ensure overlapping(x.icon, y.icon)
    -- ensure disjoint(y.text, x.icon)
    -- ensure disjoint(x.text, y.icon)
}

forall Point p {
    p.offset = 20.0
    p.icon = Circle {
        strokeWidth : 0.0
        color : rgba(0.0, 0.0, 0.0, 1.0)
        r : 3.0
    }

    p.text = Text {
        string : p.label
        center : p.icon.center + (p.offset, p.offset)
    }

    p.textLayering = p.text above p.icon
}

Point p
with Set A
where PointIn(A, p) {
    -- ensure subset(p.icon, A.icon)
    -- p.lineTo = Line {
    --          start: p.icon.center
    --          end: A.icon.center
    -- }    

    -- p.collisionPt = Circle {
    --               center: (0, 0)
    --               r: 7.
    --               color: rgba(1., 0., 0., 0.5)
    -- }

    -- Top segment
    c = A.icon.center
    hw = A.icon.w / 2.
    hh = A.icon.h / 2.
    start = c + (hw, hh)
    end = c + (-hw, hh)

    p.closestPt = Circle {
                  -- center: closestPtSeg(p.icon.center, start, end)
                  center: closestPtBox(p.icon.center, A.icon)
                  r: 7.
                  color: rgba(0., 0., 1., 0.5)
    }

    p.layering = p.icon above A.icon
}

-- Point p
-- with Set A
-- where Not(PointIn(A, p)) {
--     ensure disjoint(A.icon, p.icon)
-- }
